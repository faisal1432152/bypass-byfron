//this is bypass byfron might not work its c++ yk its hovac api but got remaked hovac api is fluxus api 
i tried my best so test it by yourself my discord name: faisal8754 might have any error fix it by yourself i didnt test it soo

#include <Windows.h>
#include <iostream>

using namespace std;


bool InjectDLL(DWORD processId, const wchar_t* dllPath) {
    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, processId);
    if (hProcess == NULL) {
        cout << "Failed to open process " << processId << ". Error code: " << GetLastError() << endl;
        return false;
    }


    LPVOID dllPathAddress = VirtualAllocEx(hProcess, NULL, (wcslen(dllPath) + 1) * sizeof(wchar_t), MEM_COMMIT, PAGE_READWRITE);
    if (dllPathAddress == NULL) {
        cout << "Failed to allocate memory in the target process. Error code: " << GetLastError() << endl;
        CloseHandle(hProcess);
        return false;
    }


    if (!WriteProcessMemory(hProcess, dllPathAddress, dllPath, (wcslen(dllPath) + 1) * sizeof(wchar_t), NULL)) {
        cout << "Failed to write DLL path into the target process. Error code: " << GetLastError() << endl;
        VirtualFreeEx(hProcess, dllPathAddress, 0, MEM_RELEASE);
        CloseHandle(hProcess);
        return false;
    }


    HMODULE hKernel32 = GetModuleHandle(L"kernel32.dll");
    if (hKernel32 == NULL) {
        cout << "Failed to get handle to kernel32.dll. Error code: " << GetLastError() << endl;
        VirtualFreeEx(hProcess, dllPathAddress, 0, MEM_RELEASE);
        CloseHandle(hProcess);
        return false;
    }

    LPVOID loadLibraryAddress = GetProcAddress(hKernel32, "LoadLibraryW");
    if (loadLibraryAddress == NULL) {
        cout << "Failed to get address of LoadLibraryW. Error code: " << GetLastError() << endl;
        VirtualFreeEx(hProcess, dllPathAddress, 0, MEM_RELEASE);
        CloseHandle(hProcess);
        return false;
    }

    HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)loadLibraryAddress, dllPathAddress, 0, NULL);
    if (hThread == NULL) {
        cout << "Failed to create remote thread in the target process. Error code: " << GetLastError() << endl;
        VirtualFreeEx(hProcess, dllPathAddress, 0, MEM_RELEASE);
        CloseHandle(hProcess);
        return false;
    }

    WaitForSingleObject(hThread, INFINITE);

    VirtualFreeEx(hProcess, dllPathAddress, 0, MEM_RELEASE);
    CloseHandle(hThread);
    CloseHandle(hProcess);

    cout << "DLL injected successfully!" << endl;

    return true;
}

int main() {
    DWORD targetProcessId = 1234; 
    const wchar_t* dllPath = L"C:\\Path\\To\\Your\\DLL\\YourDLL.dll"; //replace your dllname here

    if (InjectDLL(targetProcessId, dllPath)) {
        cout << "DLL injected successfully!" << endl;
    }
    else {
        cout << "Failed to inject DLL." << endl;
    }

    return 0;
}
